# 最终代码修改清单

## 修改文件总览

本次修改共涉及 **3个代码文件**：

1. ✅ **新建**：`app/api/generate-video/route.ts`
2. ✅ **修改**：`app/api/dify-structure-examples/route.ts`
3. ✅ **修改**：`components/stages/story-structure.tsx`

---

## 详细修改内容

### 1. 新建文件：`app/api/generate-video/route.ts`

**完整文件路径**：`app/api/generate-video/route.ts`

**主要功能**：创建专门的视频生成 API 端点

**关键代码**：

```typescript
// 第6行：API端点
const FAL_VIDEO_API_ENDPOINT = 'https://fal.run/fal-ai/hunyuan-video-v1.5/text-to-video'

// 第34-48行：请求参数
const requestBody = {
  prompt: prompt.trim(),
  aspect_ratio: hunyuanAspectRatio, // 16:9 或 9:16
  resolution: '480p',
  num_frames: 121, // 最大121帧（约5秒，24fps）
  num_inference_steps: 28,
  enable_prompt_expansion: true,
}

// 第107行：响应解析
const videoUrl = result.video?.url || result.video_url || result.url || null

// 第129-133行：返回格式
return NextResponse.json({ 
  videoUrl,
  imageUrl: videoUrl, // 保持向后兼容
  description: result.description || ''
})
```

**关键特性**：
- 使用 Hunyuan Video V1.5 模型
- 超时时间：600秒（10分钟）
- 支持多种响应格式解析
- 详细的错误处理和日志记录

---

### 2. 修改文件：`app/api/dify-structure-examples/route.ts`

**修改位置1**：第9-10行（常量定义）

```typescript
// 修改前：
const FAL_API_ENDPOINT = 'https://fal.run/fal-ai/nano-banana'

// 修改后：
const FAL_IMAGE_API_ENDPOINT = 'https://fal.run/fal-ai/nano-banana'
const FAL_VIDEO_API_ENDPOINT = 'https://fal.run/fal-ai/hunyuan-video-v1.5/text-to-video'
```

**修改位置2**：第265-338行（单个故事生成时的视频生成逻辑）

```typescript
// 修改前：生成图片
let imageUrl = ''
const imageResponse = await fetch(FAL_API_ENDPOINT, {
  body: JSON.stringify({
    prompt: imagePrompt,
    num_images: 1,
    output_format: 'jpeg',
    aspect_ratio: '16:9',
    sync_mode: true,
  }),
})

// 修改后：生成视频
let videoUrl = ''
const videoResponse = await fetch(FAL_VIDEO_API_ENDPOINT, {
  body: JSON.stringify({
    prompt: videoPrompt,
    aspect_ratio: "16:9",
    resolution: "480p",
    num_frames: 121,
    num_inference_steps: 28,
    enable_prompt_expansion: true,
  }),
})
```

**修改位置3**：第330-334行（返回数据格式）

```typescript
// 修改前：
return NextResponse.json({
  story: exampleStory,
  imageUrl: imageUrl,
  structure_type: structure_type,
})

// 修改后：
return NextResponse.json({
  story: exampleStory,
  videoUrl: videoUrl, // 新增
  imageUrl: videoUrl, // 保持向后兼容
  structure_type: structure_type,
})
```

---

### 3. 修改文件：`components/stages/story-structure.tsx`

**这是最重要的修改文件，包含多个关键修改**

#### 修改位置1：第19-24行（接口定义）

```typescript
// 修改前：
interface StoryExample {
  structure_type: string
  story: string
  imageUrl: string
}

// 修改后：
interface StoryExample {
  structure_type: string
  story: string
  imageUrl: string
  videoUrl?: string // 新增视频URL字段
}
```

#### 修改位置2：第144-261行（视频生成逻辑 - 核心修改）

**关键改动**：

1. **为每个结构创建不同的提示词**（第144-170行）：
```typescript
// 为每个结构创建不同的提示词，避免fal.ai缓存或重复
const basePrompt = `A charming illustration for a children's story: ${speciesInfo} named ${character?.name || 'a character'} in ${plot?.setting || 'a setting'}, ${plot?.conflict || 'facing a challenge'}. Colorful, friendly, and suitable for children.`

// 在循环内为每个结构添加独特的标识
const structureNames: Record<string, string> = {
  'freytag': "Freytag's Pyramid",
  'threeAct': "Three Act Structure",
  'fichtean': "Fichtean Curve"
}
const structureName = structureNames[type] || type
const videoPrompt = `${basePrompt} Story structure: ${structureName}.`
```

2. **并行生成三个视频**（第157-261行）：
```typescript
// 并行发送三个视频生成请求
// 使用 Promise.allSettled 确保即使一个失败，其他也能继续
const videoPromises = structuresToProcess.map(async ({ type, storyData }) => {
  // 每个结构只生成一个视频
  const videoResponse = await fetch("/api/generate-video", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ 
      prompt: videoPrompt, // 每个结构使用不同的prompt
      aspect_ratio: "16:9",
      user_id: userId,
      stage: 'structure'
    }),
  })
  
  // 改进的响应解析
  if (videoResponse.ok) {
    const videoData = await videoResponse.json()
    // 尝试多种可能的响应格式
    videoUrl = videoData.videoUrl || videoData.imageUrl || videoData.video?.url || videoData.video_url || ''
    // ... 详细日志记录
  }
  
  return {
    structure_type: type,
    story: storyData?.story || "Example story",
    imageUrl: imageUrl,
    videoUrl: videoUrl,
  }
})

// 等待所有视频生成完成
const videoResults = await Promise.allSettled(videoPromises)
```

3. **错误处理**（第243-263行）：
```typescript
videoResults.forEach((result, index) => {
  const structure = structuresToProcess[index]
  if (result.status === 'fulfilled') {
    generatedExamples.push(result.value)
  } else {
    // 即使失败，也添加占位符
    const fallbackResult = {
      structure_type: structure.type,
      story: structure.storyData?.story || "Example story",
      imageUrl: `https://api.dicebear.com/7.x/avataaars/svg?seed=${structure.type}`,
      videoUrl: `https://api.dicebear.com/7.x/avataaars/svg?seed=${structure.type}`,
    }
    generatedExamples.push(fallbackResult)
  }
})
```

#### 修改位置3：第295-302行（自动翻页）

```typescript
setExamples(generatedExamples)

// 检查是否有视频生成成功
const hasVideos = generatedExamples.some(e => e.videoUrl && !e.videoUrl.includes('dicebear'))
if (hasVideos) {
  toast.success("Example stories and videos generated!")
  // 自动翻页到第一个结构
  setCurrentPage(0)
} else {
  toast.success("Example stories generated!")
}
```

#### 修改位置4：第238-245行（选择结构时的处理）

```typescript
// 修改前：
const example = examples.find((e) => e.structure_type === structureType)
if (example?.imageUrl) {
  setSelectedStructureImage(example.imageUrl)
}
onStructureSelect({
  type: structure.type as any,
  outline: structure.outline,
  imageUrl: example?.imageUrl || "",
})

// 修改后：
const example = examples.find((e) => e.structure_type === structureType)
const mediaUrl = example?.videoUrl || example?.imageUrl || "" // 优先使用视频
if (mediaUrl) {
  setSelectedStructureImage(mediaUrl)
}
onStructureSelect({
  type: structure.type as any,
  outline: structure.outline,
  imageUrl: mediaUrl, // 传递视频URL或图片URL
})
```

#### 修改位置5：第540-590行（视频显示组件）

```typescript
// 修改前：使用 <img> 标签
<img
  src={example.imageUrl}
  alt={`Example for ${structure.name}`}
  className="w-full h-auto max-h-[500px] min-h-[400px] object-contain"
/>

// 修改后：使用 <video> 标签
{example.videoUrl && !example.videoUrl.includes('dicebear') ? (
  <video
    key={example.videoUrl} // 添加key确保视频重新加载
    src={example.videoUrl}
    controls
    autoPlay
    loop
    muted
    playsInline
    onError={(e) => {
      console.error(`[${example.structure_type}] Video load error:`, e)
      console.error(`[${example.structure_type}] Video URL:`, example.videoUrl)
    }}
    onLoadStart={() => {
      console.log(`[${example.structure_type}] Video loading started`)
    }}
    onLoadedData={() => {
      console.log(`[${example.structure_type}] Video loaded successfully`)
    }}
    className="w-full h-auto max-h-[500px] min-h-[400px] object-contain"
  >
    您的浏览器不支持视频播放
  </video>
) : (
  <div className="w-full h-[400px] flex items-center justify-center bg-gray-100 rounded-lg">
    <p className="text-gray-500">视频生成中或加载失败</p>
  </div>
)}
```

#### 修改位置6：第539行（条件渲染）

```typescript
// 修改前：
{example && example.imageUrl && (

// 修改后：
{example && (example.videoUrl || example.imageUrl) && (
```

---

## 关键修改点总结

### ✅ 解决的问题

1. **6个视频 → 3个视频**
   - 原因：前端循环生成 + 后端也生成 = 重复
   - 解决：前端统一处理，使用 `Promise.allSettled` 并行生成

2. **三个视频并行发送**
   - 使用 `Promise.allSettled` 同时发送三个请求

3. **自动翻页**
   - 视频生成完成后自动翻页到第一个结构

4. **为每个结构创建不同的提示词**
   - 避免 fal.ai 缓存或返回相同视频
   - 每个结构添加结构名称标识

5. **改进响应解析**
   - 尝试多种可能的响应格式
   - 添加详细的错误日志

### ⚠️ 限制

- **视频时长**：最大约5秒（Hunyuan Video V1.5的限制，无法实现15秒）

---

## 代码行数统计

- **新建文件**：`app/api/generate-video/route.ts` - 161行
- **修改文件1**：`app/api/dify-structure-examples/route.ts` - 约80行修改
- **修改文件2**：`components/stages/story-structure.tsx` - 约150行修改
- **总计**：约400行代码变更

---

## 测试要点

1. ✅ 每个结构只生成一个视频（共3个）
2. ✅ 三个视频并行发送给fal.ai
3. ✅ 生成完成后自动翻页
4. ✅ 每个结构使用不同的提示词
5. ✅ 详细的日志记录便于调试

---

**最后更新时间**：刚刚
**修改状态**：✅ 已完成


